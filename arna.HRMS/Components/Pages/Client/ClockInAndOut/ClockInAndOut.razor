@using arna.HRMS.Components.Loader
@using arna.HRMS.Components.Pages.Attendance
@using arna.HRMS.Components.lib.components.ui.Forms
@using arna.HRMS.Models.Enums
@using arna.HRMS.Models.ViewModels.Attendance
@using arna.HRMS.Services
@using arna.HRMS.Services.Auth

@implements IDisposable
@inject IClockService ClockService
@inherits AuthenticatedLayoutBase
@inject IJSRuntime JS

<!-- Loader — only when IsLoading is explicitly true -->
<Loader Visible="@IsLoading" Message="@LoaderMessage" />

<!-- Main Controls -->
<div class="d-flex align-items-center gap-2 flex-wrap">

    @if (IsEmployee())
    {
        <span class="clock-pill d-inline-flex align-items-center gap-1 rounded-pill
                     bg-light border px-2 py-1">
            <span class="clock-dot d-inline-block rounded-circle
                         @(IsClockedIn ? "bg-success" : "bg-secondary")"></span>
            <i class="bi bi-clock text-muted"></i>
            <span class="clock-time font-monospace fw-medium">@CurrentTime</span>
        </span>

        @if (IsClockedIn)
        {
            <AppButton ButtonClass="btn btn-outline-danger btn-sm rounded-pill"
                       Disabled="@DisableClockOut"
                       OnClick="ClockOutAsync">
                <i class="bi bi-stop-circle"></i>
                <span class="d-none d-sm-inline ms-1">Out</span>
            </AppButton>
        }
        else
        {
            <AppButton ButtonClass="btn btn-success btn-sm rounded-pill"
                       Disabled="@DisableClockIn"
                       OnClick="ClockInAsync">
                <i class="bi bi-play-circle @(IsClockInOut ? "clock-alert" : "")"></i>
                <span class="d-none d-sm-inline ms-1">In</span>
            </AppButton>
        }
    }

    @if (!string.IsNullOrEmpty(ActionLabel))
    {
        <span class="clock-info-pill d-none d-sm-inline-flex align-items-center
                     gap-1 rounded-pill border px-2 py-1">
            <span class="fw-semibold">@ActionLabel</span>
            <span class="font-monospace">@ActionTime</span>
        </span>
    }
</div>

@if (ShowDynamicForm)
{
    <div class="clock-modal-overlay position-fixed top-0 start-0 w-100 h-100
                d-flex align-items-center justify-content-center">
        <div class="clock-modal-card bg-white rounded-3 shadow-lg mx-3 p-4">
            <ClockInAndOutMessage Model="attendanceViewModel"
                                  OnSubmit="SubmitClockInOutAsync"
                                  OnCancel="CloseForm" />
        </div>
    </div>
}

@if (ShowToast)
{
    <div class="clock-toast-wrapper position-fixed bottom-0 end-0 p-3">
        <div class="toast show border-0 shadow-lg rounded-3 bg-white" role="alert">
            <div class="toast-body d-flex align-items-center gap-2 py-3 px-3">
                <i class="bi bi-check-circle-fill text-success fs-5"></i>
                <span>@ToastMessage</span>
            </div>
        </div>
    </div>
}

@code {

    private AttendanceViewModel attendanceViewModel = new();

    private bool IsClockedIn;
    private bool? PendingClockIn;

    private bool DisableClockOut;
    private bool DisableClockIn;

    private TimeOnly In;
    private TimeOnly Out;
    private TimeOnly AccumulatedHours;

    private string CurrentTime = "";
    private string? ActionLabel;
    private string? ActionTime;

    private bool ShowDynamicForm;
    private bool ShowToast;
    private string ToastMessage = "";

    private CancellationTokenSource? _cts;
    private CancellationTokenSource? _clockOutCooldownCts;

    private double? CurrentLatitude;
    private double? CurrentLongitude;
    private bool IsGettingLocation;

    public bool IsClockInOut = false;

    // ── Loader — defaults to false, never touched during init ──
    private bool IsLoading = false;
    private string LoaderMessage = "";

    protected override async Task OnInitializedAsync()
    {
        await base.OnInitializedAsync();
        StartClockLoop();

        var employeeId = GetEmployeeId();
        if (employeeId == 0)
            return;

        var lastEntry = await ClockService.GetClockStatusAsync(employeeId);

        if (!lastEntry.IsSuccess || lastEntry.Data == null)
            return;

        if (lastEntry.Data.ClockInTime != null
            && lastEntry.Data.ClockOutTime == null
            && lastEntry.Data.Date.Date == DateTime.Today)
        {
            IsClockedIn = true;

            In = TimeOnly.FromTimeSpan(lastEntry.Data.ClockInTime.Value);
            ActionLabel = "Clock In";
            ActionTime = In.ToString("HH:mm:ss");

            var clockInDateTime = DateTime.Today.Add(In.ToTimeSpan());
            var elapsedSeconds = (DateTime.Now - clockInDateTime).TotalSeconds;

            if (elapsedSeconds < 60)
            {
                _ = StartClockOutCooldownAsync((int)(60 - elapsedSeconds));
            }
            else
            {
                DisableClockOut = false;
            }
        }
        else
        {
            IsClockedIn = false;

            if (lastEntry.Data.ClockInTime != null
                && lastEntry.Data.ClockOutTime == null
                && lastEntry.Data.Date.Date < DateTime.Today)
            {
                IsClockInOut = true;
            }
            else
            {
                IsClockInOut = false;
            }
        }
    }

    private async Task LogDeviceToConsole()
    {
        var device = await JS.InvokeAsync<string>("deviceHelper.getDeviceType");
        await JS.InvokeVoidAsync("console.log", $"Device: {device}");
    }

    private async Task ClockInAsync()
    {
        PendingClockIn = true;
        DisableClockIn = true;

        await LogDeviceToConsole();

        var canProceed = await PrepareClockActionAsync();
        if (!canProceed)
            return;
    }

    private async Task ClockOutAsync()
    {
        if (DisableClockOut)
            return;   

        PendingClockIn = false;

        await LogDeviceToConsole();

        var canProceed = await PrepareClockActionAsync();
        if (!canProceed)
            return;
    }

    private void OpenNoteForm()
    {
        attendanceViewModel = new AttendanceViewModel();
        ShowDynamicForm = true;
    }

    private void CloseForm()
    {
        ShowDynamicForm = false;
    }

    private async Task SubmitClockInOutAsync()
    {
        if (CurrentLatitude == null || CurrentLongitude == null)
        {
            await ShowNotification("Location is required");
            return;
        }

        ShowDynamicForm = false;

        try
        {
            await SetLoading(true, PendingClockIn == true ? "Clocking in..." : "Clocking out...");

            var employeeId = GetEmployeeId();
            if (employeeId == 0)
                return;

            if (PendingClockIn == true)
            {
                IsClockedIn = true;
                In = TimeOnly.FromDateTime(DateTime.Now);

                ActionLabel = "Clock In";
                ActionTime = DateTime.Now.ToString("HH:mm:ss");

                var result = await ClockService.CreateAttendanceAsync(new AttendanceViewModel
                {
                    EmployeeId = employeeId,
                    Date = DateTime.Today,
                    ClockInTime = new TimeSpan(In.Hour, In.Minute, In.Second),
                    StatusId = AttendanceStatus.Present,
                    Notes = attendanceViewModel.Notes,
                    WorkingHours = TimeSpan.Zero,
                    Latitude = CurrentLatitude,
                    Longitude = CurrentLongitude,
                    Device = await JS.InvokeAsync<string>("deviceHelper.getDeviceType")
                });

                if (!result.IsSuccess)
                {
                    IsClockedIn = false;
                    DisableClockIn = false;
                    await ShowNotification(result.Message ?? "Clock-In failed");
                    return;
                }

                AccumulatedHours = new TimeOnly(0, 0);
                _ = StartClockOutCooldownAsync(60);
                await ShowNotification($"Clocked in at {ActionTime}");
            }
            else
            {
                IsClockedIn = false;
                DisableClockIn = false;

                Out = TimeOnly.FromDateTime(DateTime.Now);

                ActionLabel = "Clock Out";
                ActionTime = DateTime.Now.ToString("HH:mm:ss");

                var worked = Out.ToTimeSpan() - In.ToTimeSpan();
                AccumulatedHours = AccumulatedHours.Add(worked);

                IsClockInOut = false;
                var result = await ClockService.CreateAttendanceAsync(new AttendanceViewModel
                {
                    EmployeeId = employeeId,
                    Date = DateTime.Today,
                    ClockOutTime = new TimeSpan(Out.Hour, Out.Minute, Out.Second),
                    StatusId = AttendanceStatus.Present,
                    Notes = attendanceViewModel.Notes,
                    WorkingHours = AccumulatedHours.ToTimeSpan(),
                    Latitude = CurrentLatitude,
                    Longitude = CurrentLongitude,
                    Device  = await JS.InvokeAsync<string>("deviceHelper.getDeviceType")
                });

                if (!result.IsSuccess)
                {
                    await ShowNotification(result.Message ?? "Clock-Out failed");
                    return;
                }

                await ShowNotification($"Clocked out | {new TimeSpan(Out.Hour, Out.Minute, Out.Second)}");
            }
            CurrentLatitude = null;
            CurrentLongitude = null;
        }
        finally
        {
            // ── Always hide loader no matter what ──
            await SetLoading(false);
        }
    }

    private void StartClockLoop()
    {
        _cts?.Cancel();
        _cts = new CancellationTokenSource();
        var ct = _cts.Token;

        var timer = new PeriodicTimer(TimeSpan.FromSeconds(1));
        _ = Task.Run(async () =>
        {
            try
            {
                while (await timer.WaitForNextTickAsync(ct))
                {
                    UpdateCurrentTime();
                    await InvokeAsync(StateHasChanged);
                }
            }
            catch (OperationCanceledException) { }
            finally
            {
                timer.Dispose();
            }
        }, ct);
    }

    private async Task StartClockOutCooldownAsync(int seconds)
    {
        _clockOutCooldownCts?.Cancel();
        _clockOutCooldownCts = new CancellationTokenSource();
        var ct = _clockOutCooldownCts.Token;

        DisableClockOut = true;
        await InvokeAsync(StateHasChanged);

        try
        {
            await Task.Delay(TimeSpan.FromSeconds(seconds), ct);
            DisableClockOut = false;
            await InvokeAsync(StateHasChanged);
        }
        catch (OperationCanceledException) { }
    }

    private async Task ShowNotification(string message)
    {
        ToastMessage = message;
        ShowToast = true;
        await InvokeAsync(StateHasChanged);

        try
        {
            await Task.Delay(2500);
        }
        catch (OperationCanceledException) { }

        ShowToast = false;
        await InvokeAsync(StateHasChanged);
    }

    private void UpdateCurrentTime()
    {
        CurrentTime = DateTime.Now.ToString("HH:mm:ss");
    }

    public void Dispose()
    {
        _cts?.Cancel();
        _cts?.Dispose();
        _clockOutCooldownCts?.Cancel();
        _clockOutCooldownCts?.Dispose();
    }

    private async Task<bool> PrepareClockActionAsync()
    {
        try
        {
            await SetLoading(true, "Getting location...");

            IsGettingLocation = true;
            var location = await ClockService.GetCurrentLocationAsync();
            IsGettingLocation = false;

            if (location == null)
            {
                DisableClockIn = false;
                DisableClockOut = false;
                await ShowNotification("Location permission is required");
                return false;
            }

            CurrentLatitude = location.Value.Latitude;
            CurrentLongitude = location.Value.Longitude;

            OpenNoteForm();
            return true;
        }
        finally
        {
            // ── Always hide loader ──
            await SetLoading(false);
        }
    }

    // ── Single safe method for loader state ──
    private async Task SetLoading(bool show, string message = "")
    {
        IsLoading = show;
        LoaderMessage = show ? message : "";
        await InvokeAsync(StateHasChanged);
    }
}